{
  "manifest": {
    "name": "path-to-regexp",
    "description": "Express style path to RegExp utility",
    "version": "3.2.0",
    "main": "index.js",
    "typings": "index.d.ts",
    "files": [
      "index.js",
      "index.d.ts",
      "LICENSE"
    ],
    "scripts": {
      "lint": "standard",
      "test-spec": "mocha --require ts-node/register -R spec --bail test.ts",
      "test-cov": "nyc --reporter=lcov mocha -- --require ts-node/register -R spec test.ts",
      "coverage": "nyc report --reporter=text-lcov",
      "test": "npm run lint && npm run test-cov"
    },
    "keywords": [
      "express",
      "regexp",
      "route",
      "routing"
    ],
    "component": {
      "scripts": {
        "path-to-regexp": "index.js"
      }
    },
    "license": "MIT",
    "repository": {
      "type": "git",
      "url": "https://github.com/pillarjs/path-to-regexp.git"
    },
    "devDependencies": {
      "@types/chai": "^4.0.4",
      "@types/mocha": "^5.2.5",
      "@types/node": "^12.7.3",
      "chai": "^4.1.1",
      "mocha": "^6.2.0",
      "nyc": "^14.1.1",
      "standard": "^14.1.0",
      "ts-node": "^8.3.0",
      "typescript": "^3.7.2"
    },
    "_registry": "npm",
    "_loc": "/home/node/.cache/yarn/v6/npm-path-to-regexp-3.2.0-fa7877ecbc495c601907562222453c43cc204a5f-integrity/node_modules/path-to-regexp/package.json",
    "readmeFilename": "Readme.md",
    "readme": "# Path-to-RegExp\n\n> Turn a path string such as `/user/:name` into a regular expression.\n\n[![NPM version][npm-image]][npm-url]\n[![Build status][travis-image]][travis-url]\n[![Test coverage][coveralls-image]][coveralls-url]\n[![Dependency Status][david-image]][david-url]\n[![License][license-image]][license-url]\n[![Downloads][downloads-image]][downloads-url]\n\n## Installation\n\n```\nnpm install path-to-regexp --save\n```\n\n## Usage\n\n```javascript\nconst pathToRegexp = require('path-to-regexp')\n\n// pathToRegexp(path, keys?, options?)\n// pathToRegexp.match(path)\n// pathToRegexp.parse(path)\n// pathToRegexp.compile(path)\n```\n\n- **path** A string, array of strings, or a regular expression.\n- **keys** An array to populate with keys found in the path.\n- **options**\n  - **sensitive** When `true` the regexp will be case sensitive. (default: `false`)\n  - **strict** When `true` the regexp allows an optional trailing delimiter to match. (default: `false`)\n  - **end** When `true` the regexp will match to the end of the string. (default: `true`)\n  - **start** When `true` the regexp will match from the beginning of the string. (default: `true`)\n  - **delimiter** The default delimiter for segments. (default: `'/'`)\n  - **endsWith** Optional character, or list of characters, to treat as \"end\" characters.\n  - **whitelist** List of characters to consider delimiters when parsing. (default: `undefined`, any character)\n\n```javascript\nconst keys = []\nconst regexp = pathToRegexp('/foo/:bar', keys)\n// regexp = /^\\/foo\\/([^\\/]+?)\\/?$/i\n// keys = [{ name: 'bar', prefix: '/', delimiter: '/', optional: false, repeat: false, pattern: '[^\\\\/]+?' }]\n```\n\n**Please note:** The `RegExp` returned by `path-to-regexp` is intended for ordered data (e.g. pathnames, hostnames). It can not handle arbitrarily ordered data (e.g. query strings, URL fragments, JSON, etc).\n\n### Parameters\n\nThe path argument is used to define parameters and populate the list of keys.\n\n#### Named Parameters\n\nNamed parameters are defined by prefixing a colon to the parameter name (`:foo`). By default, the parameter will match until the next prefix (e.g. `[^/]+`).\n\n```js\nconst regexp = pathToRegexp('/:foo/:bar')\n// keys = [{ name: 'foo', prefix: '/', ... }, { name: 'bar', prefix: '/', ... }]\n\nregexp.exec('/test/route')\n//=> [ '/test/route', 'test', 'route', index: 0, input: '/test/route', groups: undefined ]\n```\n\n**Please note:** Parameter names must use \"word characters\" (`[A-Za-z0-9_]`).\n\n#### Parameter Modifiers\n\n##### Optional\n\nParameters can be suffixed with a question mark (`?`) to make the parameter optional.\n\n```js\nconst regexp = pathToRegexp('/:foo/:bar?')\n// keys = [{ name: 'foo', ... }, { name: 'bar', delimiter: '/', optional: true, repeat: false }]\n\nregexp.exec('/test')\n//=> [ '/test', 'test', undefined, index: 0, input: '/test', groups: undefined ]\n\nregexp.exec('/test/route')\n//=> [ '/test/route', 'test', 'route', index: 0, input: '/test/route', groups: undefined ]\n```\n\n**Tip:** The prefix is also optional, escape the prefix `\\/` to make it required.\n\n##### Zero or more\n\nParameters can be suffixed with an asterisk (`*`) to denote a zero or more parameter matches. The prefix is used for each match.\n\n```js\nconst regexp = pathToRegexp('/:foo*')\n// keys = [{ name: 'foo', delimiter: '/', optional: true, repeat: true }]\n\nregexp.exec('/')\n//=> [ '/', undefined, index: 0, input: '/', groups: undefined ]\n\nregexp.exec('/bar/baz')\n//=> [ '/bar/baz', 'bar/baz', index: 0, input: '/bar/baz', groups: undefined ]\n```\n\n##### One or more\n\nParameters can be suffixed with a plus sign (`+`) to denote a one or more parameter matches. The prefix is used for each match.\n\n```js\nconst regexp = pathToRegexp('/:foo+')\n// keys = [{ name: 'foo', delimiter: '/', optional: false, repeat: true }]\n\nregexp.exec('/')\n//=> null\n\nregexp.exec('/bar/baz')\n//=> [ '/bar/baz','bar/baz', index: 0, input: '/bar/baz', groups: undefined ]\n```\n\n#### Unnamed Parameters\n\nIt is possible to write an unnamed parameter that only consists of a matching group. It works the same as a named parameter, except it will be numerically indexed.\n\n```js\nconst regexp = pathToRegexp('/:foo/(.*)')\n// keys = [{ name: 'foo', ... }, { name: 0, ... }]\n\nregexp.exec('/test/route')\n//=> [ '/test/route', 'test', 'route', index: 0, input: '/test/route', groups: undefined ]\n```\n\n#### Custom Matching Parameters\n\nAll parameters can have a custom regexp, which overrides the default match (`[^/]+`). For example, you can match digits or names in a path:\n\n```js\nconst regexpNumbers = pathToRegexp('/icon-:foo(\\\\d+).png')\n// keys = [{ name: 'foo', ... }]\n\nregexpNumbers.exec('/icon-123.png')\n//=> ['/icon-123.png', '123']\n\nregexpNumbers.exec('/icon-abc.png')\n//=> null\n\nconst regexpWord = pathToRegexp('/(user|u)')\n// keys = [{ name: 0, ... }]\n\nregexpWord.exec('/u')\n//=> ['/u', 'u']\n\nregexpWord.exec('/users')\n//=> null\n```\n\n**Tip:** Backslashes need to be escaped with another backslash in JavaScript strings.\n\n### Match\n\nThe `match` function will return a function for transforming paths into parameters:\n\n```js\nconst match = pathToRegexp.match('/user/:id')\n\nmatch('/user/123') //=> { path: '/user/123', index: 0, params: { id: '123' } }\nmatch('/invalid') //=> false\n```\n\n### Parse\n\nThe `parse` function will return a list of strings and keys from a path string:\n\n```js\nconst tokens = pathToRegexp.parse('/route/:foo/(.*)')\n\nconsole.log(tokens[0])\n//=> \"/route\"\n\nconsole.log(tokens[1])\n//=> { name: 'foo', prefix: '/', delimiter: '/', optional: false, repeat: false, pattern: '[^\\\\/]+?' }\n\nconsole.log(tokens[2])\n//=> { name: 0, prefix: '/', delimiter: '/', optional: false, repeat: false, pattern: '.*' }\n```\n\n**Note:** This method only works with strings.\n\n### Compile (\"Reverse\" Path-To-RegExp)\n\nThe `compile` function will return a function for transforming parameters into a valid path:\n\n```js\nconst toPath = pathToRegexp.compile('/user/:id')\n\ntoPath({ id: 123 }) //=> \"/user/123\"\ntoPath({ id: 'cafÃ©' }) //=> \"/user/caf%C3%A9\"\ntoPath({ id: '/' }) //=> \"/user/%2F\"\n\ntoPath({ id: ':/' }) //=> \"/user/%3A%2F\"\ntoPath({ id: ':/' }, { encode: (value, token) => value, validate: false }) //=> \"/user/:/\"\n\nconst toPathRepeated = pathToRegexp.compile('/:segment+')\n\ntoPathRepeated({ segment: 'foo' }) //=> \"/foo\"\ntoPathRepeated({ segment: ['a', 'b', 'c'] }) //=> \"/a/b/c\"\n\nconst toPathRegexp = pathToRegexp.compile('/user/:id(\\\\d+)')\n\ntoPathRegexp({ id: 123 }) //=> \"/user/123\"\ntoPathRegexp({ id: '123' }) //=> \"/user/123\"\ntoPathRegexp({ id: 'abc' }) //=> Throws `TypeError`.\ntoPathRegexp({ id: 'abc' }, { validate: false }) //=> \"/user/abc\"\n```\n\n**Note:** The generated function will throw on invalid input. It will do all necessary checks to ensure the generated path is valid. This method only works with strings.\n\n### Working with Tokens\n\nPath-To-RegExp exposes the two functions used internally that accept an array of tokens.\n\n* `pathToRegexp.tokensToRegExp(tokens, keys?, options?)` Transform an array of tokens into a matching regular expression.\n* `pathToRegexp.tokensToFunction(tokens)` Transform an array of tokens into a path generator function.\n\n#### Token Information\n\n* `name` The name of the token (`string` for named or `number` for index)\n* `prefix` The prefix character for the segment (e.g. `/`)\n* `delimiter` The delimiter for the segment (same as prefix or default delimiter)\n* `optional` Indicates the token is optional (`boolean`)\n* `repeat` Indicates the token is repeated (`boolean`)\n* `pattern` The RegExp used to match this token (`string`)\n\n## Compatibility with Express <= 4.x\n\nPath-To-RegExp breaks compatibility with Express <= `4.x`:\n\n* RegExp special characters can only be used in a parameter\n  * Express.js 4.x used all `RegExp` special characters regardless of position - this considered a bug\n* Parameters have suffixes that augment meaning - `*`, `+` and `?`. E.g. `/:user*`\n* No wildcard asterisk (`*`) - use parameters instead (`(.*)`)\n\n## TypeScript\n\nIncludes a [`.d.ts`](index.d.ts) file for TypeScript users.\n\n## Live Demo\n\nYou can see a live demo of this library in use at [express-route-tester](http://forbeslindesay.github.com/express-route-tester/).\n\n## License\n\nMIT\n\n[npm-image]: https://img.shields.io/npm/v/path-to-regexp.svg?style=flat\n[npm-url]: https://npmjs.org/package/path-to-regexp\n[travis-image]: https://img.shields.io/travis/pillarjs/path-to-regexp.svg?style=flat\n[travis-url]: https://travis-ci.org/pillarjs/path-to-regexp\n[coveralls-image]: https://img.shields.io/coveralls/pillarjs/path-to-regexp.svg?style=flat\n[coveralls-url]: https://coveralls.io/r/pillarjs/path-to-regexp?branch=master\n[david-image]: http://img.shields.io/david/pillarjs/path-to-regexp.svg?style=flat\n[david-url]: https://david-dm.org/pillarjs/path-to-regexp\n[license-image]: http://img.shields.io/npm/l/path-to-regexp.svg?style=flat\n[license-url]: LICENSE.md\n[downloads-image]: http://img.shields.io/npm/dm/path-to-regexp.svg?style=flat\n[downloads-url]: https://npmjs.org/package/path-to-regexp\n",
    "licenseText": "The MIT License (MIT)\n\nCopyright (c) 2014 Blake Embrey (hello@blakeembrey.com)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.yarnpkg.com/path-to-regexp/-/path-to-regexp-3.2.0.tgz#fa7877ecbc495c601907562222453c43cc204a5f",
    "type": "tarball",
    "reference": "https://registry.yarnpkg.com/path-to-regexp/-/path-to-regexp-3.2.0.tgz",
    "hash": "fa7877ecbc495c601907562222453c43cc204a5f",
    "integrity": "sha512-jczvQbCUS7XmS7o+y1aEO9OBVFeZBQ1MDSEqmO7xSoPgOPoowY/SxLpZ6Vh97/8qHZOteiCKb7gkG9gA2ZUxJA==",
    "registry": "npm",
    "packageName": "path-to-regexp",
    "cacheIntegrity": "sha512-jczvQbCUS7XmS7o+y1aEO9OBVFeZBQ1MDSEqmO7xSoPgOPoowY/SxLpZ6Vh97/8qHZOteiCKb7gkG9gA2ZUxJA== sha1-+nh37LxJXGAZB1YiIkU8Q8wgSl8="
  },
  "registry": "npm",
  "hash": "fa7877ecbc495c601907562222453c43cc204a5f"
}