{
  "manifest": {
    "version": "2.0.0",
    "name": "resolve.exports",
    "repository": {
      "type": "git",
      "url": "https://github.com/lukeed/resolve.exports.git"
    },
    "description": "A tiny (952b), correct, general-purpose, and configurable \"exports\" and \"imports\" resolver without file-system reliance",
    "module": "dist/index.mjs",
    "main": "dist/index.js",
    "types": "index.d.ts",
    "license": "MIT",
    "author": {
      "name": "Luke Edwards",
      "email": "luke.edwards05@gmail.com",
      "url": "https://lukeed.com"
    },
    "engines": {
      "node": ">=10"
    },
    "scripts": {
      "build": "bundt -m",
      "types": "tsc --noEmit",
      "test": "uvu -r tsm test"
    },
    "files": [
      "*.d.ts",
      "dist"
    ],
    "exports": {
      ".": {
        "types": "./index.d.ts",
        "import": "./dist/index.mjs",
        "require": "./dist/index.js"
      },
      "./package.json": "./package.json"
    },
    "keywords": [
      "esm",
      "exports",
      "esmodules",
      "fields",
      "modules",
      "resolution",
      "resolve"
    ],
    "devDependencies": {
      "bundt": "next",
      "tsm": "2.3.0",
      "typescript": "4.9.4",
      "uvu": "0.5.4"
    },
    "_registry": "npm",
    "_loc": "/home/node/.cache/yarn/v6/npm-resolve-exports-2.0.0-c1a0028c2d166ec2fbf7d0644584927e76e7400e-integrity/node_modules/resolve.exports/package.json",
    "readmeFilename": "readme.md",
    "readme": "# resolve.exports [![CI](https://github.com/lukeed/resolve.exports/workflows/CI/badge.svg)](https://github.com/lukeed/resolve.exports/actions) [![codecov](https://codecov.io/gh/lukeed/resolve.exports/branch/master/graph/badge.svg?token=4P7d4Omw2h)](https://codecov.io/gh/lukeed/resolve.exports)\n\n> A tiny (952b), correct, general-purpose, and configurable `\"exports\"` and `\"imports\"` resolver without file-system reliance\n\n***Why?***\n\nHopefully, this module may serve as a reference point (and/or be used directly) so that the varying tools and bundlers within the ecosystem can share a common approach with one another **as well as** with the native Node.js implementation.\n\nWith the push for ESM, we must be _very_ careful and avoid fragmentation. If we, as a community, begin propagating different _dialects_ of the resolution algorithm, then we're headed for deep trouble. It will make supporting (and using) `\"exports\"` nearly impossible, which may force its abandonment and along with it, its benefits.\n\nLet's have nice things.\n\n## Install\n\n```sh\n$ npm install resolve.exports\n```\n\n## Usage\n\n> Please see [`/test/`](/test) for examples.\n\n```js\nimport * as resolve from 'resolve.exports';\n\n// package.json contents\nconst pkg = {\n  \"name\": \"foobar\",\n  \"module\": \"dist/module.mjs\",\n  \"main\": \"dist/require.js\",\n  \"imports\": {\n    \"#hash\": {\n      \"import\": {\n        \"browser\": \"./hash/web.mjs\",\n        \"node\": \"./hash/node.mjs\",\n      },\n      \"default\": \"./hash/detect.js\"\n    }\n  },\n  \"exports\": {\n    \".\": {\n      \"import\": \"./dist/module.mjs\",\n      \"require\": \"./dist/require.js\"\n    },\n    \"./lite\": {\n      \"worker\": {\n        \"browser\": \"./lite/worker.brower.js\",\n        \"node\": \"./lite/worker.node.js\"\n      },\n      \"import\": \"./lite/module.mjs\",\n      \"require\": \"./lite/require.js\"\n    }\n  }\n};\n\n// ---\n// Exports\n// ---\n\n// entry: \"foobar\" === \".\" === default\n// conditions: [\"default\", \"import\", \"node\"]\nresolve.exports(pkg);\nresolve.exports(pkg, '.');\nresolve.exports(pkg, 'foobar');\n//=> [\"./dist/module.mjs\"]\n\n// entry: \"foobar/lite\" === \"./lite\"\n// conditions: [\"default\", \"import\", \"node\"]\nresolve.exports(pkg, 'foobar/lite');\nresolve.exports(pkg, './lite');\n//=> [\"./lite/module.mjs\"]\n\n// Enable `require` condition\n// conditions: [\"default\", \"require\", \"node\"]\nresolve.exports(pkg, 'foobar', { require: true }); //=> [\"./dist/require.js\"]\nresolve.exports(pkg, './lite', { require: true }); //=> [\"./lite/require.js\"]\n\n// Throws \"Missing <entry> specifier in <name> package\" Error\nresolve.exports(pkg, 'foobar/hello');\nresolve.exports(pkg, './hello/world');\n\n// Add custom condition(s)\n// conditions: [\"default\", \"worker\", \"import\", \"node\"]\nresolve.exports(pkg, 'foobar/lite', {\n  conditions: ['worker']\n}); //=> [\"./lite/worker.node.js\"]\n\n// Toggle \"browser\" condition\n// conditions: [\"default\", \"worker\", \"import\", \"browser\"]\nresolve.exports(pkg, 'foobar/lite', {\n  conditions: ['worker'],\n  browser: true\n}); //=> [\"./lite/worker.browser.js\"]\n\n// Disable non-\"default\" condition activate\n// NOTE: breaks from Node.js default behavior\n// conditions: [\"default\", \"custom\"]\nresolve.exports(pkg, 'foobar/lite', {\n  conditions: ['custom'],\n  unsafe: true,\n});\n//=> Error: No known conditions for \"./lite\" specifier in \"foobar\" package\n\n// ---\n// Imports\n// ---\n\n// conditions: [\"default\", \"import\", \"node\"]\nresolve.imports(pkg, '#hash');\nresolve.imports(pkg, 'foobar/#hash');\n//=> [\"./hash/node.mjs\"]\n\n// conditions: [\"default\", \"import\", \"browser\"]\nresolve.imports(pkg, '#hash', { browser: true });\nresolve.imports(pkg, 'foobar/#hash');\n//=> [\"./hash/web.mjs\"]\n\n// conditions: [\"default\"]\nresolve.imports(pkg, '#hash', { unsafe: true });\nresolve.imports(pkg, 'foobar/#hash');\n//=> [\"./hash/detect.mjs\"]\n\nresolve.imports(pkg, '#hello/world');\nresolve.imports(pkg, 'foobar/#hello/world');\n//=> Error: Missing \"#hello/world\" specifier in \"foobar\" package\n\n// ---\n// Legacy\n// ---\n\n// prefer \"module\" > \"main\" (default)\nresolve.legacy(pkg); //=> \"dist/module.mjs\"\n\n// customize fields order\nresolve.legacy(pkg, {\n  fields: ['main', 'module']\n}); //=> \"dist/require.js\"\n```\n\n## API\n\nThe [`resolve()`](#resolvepkg-entry-options), [`exports()`](#exportspkg-entry-options), and [`imports()`](#importspkg-target-options) functions share similar API signatures:\n\n```ts\nexport function resolve(pkg: Package, entry?: string, options?: Options): string[] | undefined;\nexport function exports(pkg: Package, entry?: string, options?: Options): string[] | undefined;\nexport function imports(pkg: Package, target: string, options?: Options): string[] | undefined;\n//                                         ^ not optional!\n```\n\nAll three:\n* accept a `package.json` file's contents as a JSON object\n* accept a target/entry identifier\n* may accept an [Options](#options) object\n* return `string[]`, `string`, or `undefined`\n\nThe only difference is that `imports()` must accept a target identifier as there can be no inferred default.\n\nSee below for further API descriptions.\n\n> **Note:** There is also a [Legacy Resolver API](#legacy-resolver)\n\n---\n\n### resolve(pkg, entry?, options?)\nReturns: `string[]` or `undefined`\n\nA convenience helper which automatically reroutes to [`exports()`](#exportspkg-entry-options) or [`imports()`](#importspkg-target-options) depending on the `entry` value.\n\nWhen unspecified, `entry` defaults to the `\".\"` identifier, which means that `exports()` will be invoked.\n\n```js\nimport * as r from 'resolve.exports';\n\nlet pkg = {\n  name: 'foobar',\n  // ...\n};\n\nr.resolve(pkg);\n//~> r.exports(pkg, '.');\n\nr.resolve(pkg, 'foobar');\n//~> r.exports(pkg, '.');\n\nr.resolve(pkg, 'foobar/subpath');\n//~> r.exports(pkg, './subpath');\n\nr.resolve(pkg, '#hash/md5');\n//~> r.imports(pkg, '#hash/md5');\n\nr.resolve(pkg, 'foobar/#hash/md5');\n//~> r.imports(pkg, '#hash/md5');\n```\n\n### exports(pkg, entry?, options?)\nReturns: `string[]` or `undefined`\n\nTraverse the `\"exports\"` within the contents of a `package.json` file. <br>\nIf the contents _does not_ contain an `\"exports\"` map, then `undefined` will be returned.\n\nSuccessful resolutions will always result in a `string` or `string[]` value. This will be the value of the resolved mapping itself – which means that the output is a relative file path.\n\nThis function may throw an Error if:\n\n* the requested `entry` cannot be resolved (aka, not defined in the `\"exports\"` map)\n* an `entry` _is_ defined but no known conditions were matched (see [`options.conditions`](#optionsconditions))\n\n#### pkg\nType: `object` <br>\nRequired: `true`\n\nThe `package.json` contents.\n\n#### entry\nType: `string` <br>\nRequired: `false` <br>\nDefault: `.` (aka, root)\n\nThe desired target entry, or the original `import` path.\n\nWhen `entry` _is not_ a relative path (aka, does not start with `'.'`), then `entry` is given the `'./'` prefix.\n\nWhen `entry` begins with the package name (determined via the `pkg.name` value), then `entry` is truncated and made relative.\n\nWhen `entry` is already relative, it is accepted as is.\n\n***Examples***\n\nAssume we have a module named \"foobar\" and whose `pkg` contains `\"name\": \"foobar\"`.\n\n| `entry` value | treated as | reason |\n|-|-|-|\n| `null` / `undefined` | `'.'` | default |\n| `'.'` | `'.'` | value was relative |\n| `'foobar'` | `'.'` | value was `pkg.name` |\n| `'foobar/lite'` | `'./lite'` | value had `pkg.name` prefix |\n| `'./lite'` | `'./lite'` | value was relative |\n| `'lite'` | `'./lite'` | value was not relative & did not have `pkg.name` prefix |\n\n\n### imports(pkg, target, options?)\nReturns: `string[]` or `undefined`\n\nTraverse the `\"imports\"` within the contents of a `package.json` file. <br>\nIf the contents _does not_ contain an `\"imports\"` map, then `undefined` will be returned.\n\nSuccessful resolutions will always result in a `string` or `string[]` value. This will be the value of the resolved mapping itself – which means that the output is a relative file path.\n\nThis function may throw an Error if:\n\n* the requested `target` cannot be resolved (aka, not defined in the `\"imports\"` map)\n* an `target` _is_ defined but no known conditions were matched (see [`options.conditions`](#optionsconditions))\n\n#### pkg\nType: `object` <br>\nRequired: `true`\n\nThe `package.json` contents.\n\n#### target\nType: `string` <br>\nRequired: `true`\n\nThe target import identifier; for example, `#hash` or `#hash/md5`.\n\nImport specifiers _must_ begin with the `#` character, as required by the resolution specification. However, if `target` begins with the package name (determined by the `pkg.name` value), then `resolve.exports` will trim it from the `target` identifier. For example, `\"foobar/#hash/md5\"` will be treated as `\"#hash/md5\"` for the `\"foobar\"` package.\n\n## Options\n\nThe [`resolve()`](#resolvepkg-entry-options), [`imports()`](#importspkg-target-options), and [`exports()`](#exportspkg-entry-options) functions share these options. All properties are optional and you are not required to pass an `options` argument.\n\nCollectively, the `options` are used to assemble a list of [conditions](https://nodejs.org/docs/latest-v18.x/api/packages.html#conditional-exports) that should be activated while resolving your target(s).\n\n> **Note:** Although the Node.js documentation primarily showcases conditions alongside `\"exports\"` usage, they also apply to `\"imports\"` maps too. _([example](https://nodejs.org/docs/latest-v18.x/api/packages.html#subpath-imports))_\n\n#### options.require\nType: `boolean` <br>\nDefault: `false`\n\nWhen truthy, the `\"require\"` field is added to the list of allowed/known conditions. <br>\nOtherwise the `\"import\"` field is added instead.\n\n#### options.browser\nType: `boolean` <br>\nDefault: `false`\n\nWhen truthy, the `\"browser\"` field is added to the list of allowed/known conditions. <br>\nOtherwise the `\"node\"` field is added instead.\n\n#### options.conditions\nType: `string[]` <br>\nDefault: `[]`\n\nA list of additional/custom conditions that should be accepted when seen.\n\n> **Important:** The order specified within `options.conditions` does not matter. <br>The matching order/priority is **always** determined by the `\"exports\"` map's key order.\n\nFor example, you may choose to accept a `\"production\"` condition in certain environments. Given the following `pkg` content:\n\n```js\nconst pkg = {\n  // package.json ...\n  \"exports\": {\n    \"worker\": \"./$worker.js\",\n    \"require\": \"./$require.js\",\n    \"production\": \"./$production.js\",\n    \"import\": \"./$import.mjs\",\n  }\n};\n\nresolve.exports(pkg, '.');\n// Conditions: [\"default\", \"import\", \"node\"]\n//=> [\"./$import.mjs\"]\n\nresolve.exports(pkg, '.', {\n  conditions: ['production']\n});\n// Conditions: [\"default\", \"production\", \"import\", \"node\"]\n//=> [\"./$production.js\"]\n\nresolve.exports(pkg, '.', {\n  conditions: ['production'],\n  require: true,\n});\n// Conditions: [\"default\", \"production\", \"require\", \"node\"]\n//=> [\"./$require.js\"]\n\nresolve.exports(pkg, '.', {\n  conditions: ['production', 'worker'],\n  require: true,\n});\n// Conditions: [\"default\", \"production\", \"worker\", \"require\", \"node\"]\n//=> [\"./$worker.js\"]\n\nresolve.exports(pkg, '.', {\n  conditions: ['production', 'worker']\n});\n// Conditions: [\"default\", \"production\", \"worker\", \"import\", \"node\"]\n//=> [\"./$worker.js\"]\n```\n\n#### options.unsafe\nType: `boolean` <br>\nDefault: `false`\n\n> **Important:** You probably do not want this option! <br>It will break out of Node's default resolution conditions.\n\nWhen enabled, this option will ignore **all other options** except [`options.conditions`](#optionsconditions). This is because, when enabled, `options.unsafe` **does not** assume or provide any default conditions except the `\"default\"` condition.\n\n```js\nresolve.exports(pkg, '.');\n//=> Conditions: [\"default\", \"import\", \"node\"]\n\nresolve.exports(pkg, '.', { unsafe: true });\n//=> Conditions: [\"default\"]\n\nresolve.exports(pkg, '.', { unsafe: true, require: true, browser: true });\n//=> Conditions: [\"default\"]\n```\n\nIn other words, this means that trying to use `options.require` or `options.browser` alongside `options.unsafe` will have no effect. In order to enable these conditions, you must provide them manually into the `options.conditions` list:\n\n```js\nresolve.exports(pkg, '.', {\n  unsafe: true,\n  conditions: [\"require\"]\n});\n//=> Conditions: [\"default\", \"require\"]\n\nresolve.exports(pkg, '.', {\n  unsafe: true,\n  conditions: [\"browser\", \"require\", \"custom123\"]\n});\n//=> Conditions: [\"default\", \"browser\", \"require\", \"custom123\"]\n```\n\n## Legacy Resolver\n\nAlso included is a \"legacy\" method for resolving non-`\"exports\"` package fields. This may be used as a fallback method when for when no `\"exports\"` mapping is defined. In other words, it's completely optional (and tree-shakeable).\n\n### legacy(pkg, options?)\nReturns: `string` or `undefined`\n\nYou may customize the field priority via [`options.fields`](#optionsfields).\n\nWhen a field is found, its value is returned _as written_. <br>\nWhen no fields were found, `undefined` is returned. If you wish to mimic Node.js behavior, you can assume this means `'index.js'` – but this module does not make that assumption for you.\n\n#### options.browser\nType: `boolean` or `string` <br>\nDefault: `false`\n\nWhen truthy, ensures that the `'browser'` field is part of the acceptable `fields` list.\n\n> **Important:** If your custom [`options.fields`](#optionsfields) value includes `'browser'`, then _your_ order is respected. <br>Otherwise, when truthy, `options.browser` will move `'browser'` to the front of the list, making it the top priority.\n\nWhen `true` and `\"browser\"` is an object, then `legacy()` will return the the entire `\"browser\"` object.\n\nYou may also pass a string value, which will be treated as an import/file path. When this is the case and `\"browser\"` is an object, then `legacy()` may return:\n\n* `false` – if the package author decided a file should be ignored; or\n* your `options.browser` string value – but made relative, if not already\n\n> See the [`\"browser\" field specification](https://github.com/defunctzombie/package-browser-field-spec) for more information.\n\n#### options.fields\nType: `string[]` <br>\nDefault: `['module', 'main']`\n\nA list of fields to accept. The order of the array determines the priority/importance of each field, with the most important fields at the beginning of the list.\n\nBy default, the `legacy()` method will accept any `\"module\"` and/or \"main\" fields if they are defined. However, if both fields are defined, then \"module\" will be returned.\n\n```js\nimport { legacy } from 'resolve.exports';\n\n// package.json\nconst pkg = {\n  \"name\": \"...\",\n  \"worker\": \"worker.js\",\n  \"module\": \"module.mjs\",\n  \"browser\": \"browser.js\",\n  \"main\": \"main.js\",\n};\n\nlegacy(pkg);\n// fields = [module, main]\n//=> \"module.mjs\"\n\nlegacy(pkg, { browser: true });\n// fields = [browser, module, main]\n//=> \"browser.mjs\"\n\nlegacy(pkg, {\n  fields: ['missing', 'worker', 'module', 'main']\n});\n// fields = [missing, worker, module, main]\n//=> \"worker.js\"\n\nlegacy(pkg, {\n  fields: ['missing', 'worker', 'module', 'main'],\n  browser: true,\n});\n// fields = [browser, missing, worker, module, main]\n//=> \"browser.js\"\n\nlegacy(pkg, {\n  fields: ['module', 'browser', 'main'],\n  browser: true,\n});\n// fields = [module, browser, main]\n//=> \"module.mjs\"\n```\n\n## License\n\nMIT © [Luke Edwards](https://lukeed.com)\n",
    "licenseText": "The MIT License (MIT)\n\nCopyright (c) Luke Edwards <luke.edwards05@gmail.com> (lukeed.com)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.yarnpkg.com/resolve.exports/-/resolve.exports-2.0.0.tgz#c1a0028c2d166ec2fbf7d0644584927e76e7400e",
    "type": "tarball",
    "reference": "https://registry.yarnpkg.com/resolve.exports/-/resolve.exports-2.0.0.tgz",
    "hash": "c1a0028c2d166ec2fbf7d0644584927e76e7400e",
    "integrity": "sha512-6K/gDlqgQscOlg9fSRpWstA8sYe8rbELsSTNpx+3kTrsVCzvSl0zIvRErM7fdl9ERWDsKnrLnwB+Ne89918XOg==",
    "registry": "npm",
    "packageName": "resolve.exports",
    "cacheIntegrity": "sha512-6K/gDlqgQscOlg9fSRpWstA8sYe8rbELsSTNpx+3kTrsVCzvSl0zIvRErM7fdl9ERWDsKnrLnwB+Ne89918XOg== sha1-waACjC0WbsL799BkRYSSfnbnQA4="
  },
  "registry": "npm",
  "hash": "c1a0028c2d166ec2fbf7d0644584927e76e7400e"
}