{
  "manifest": {
    "name": "busboy",
    "version": "1.6.0",
    "author": {
      "name": "Brian White",
      "email": "mscdex@mscdex.net"
    },
    "description": "A streaming parser for HTML form data for node.js",
    "main": "./lib/index.js",
    "dependencies": {
      "streamsearch": "^1.1.0"
    },
    "devDependencies": {
      "@mscdex/eslint-config": "^1.1.0",
      "eslint": "^7.32.0"
    },
    "scripts": {
      "test": "node test/test.js",
      "lint": "eslint --cache --report-unused-disable-directives --ext=.js .eslintrc.js lib test bench",
      "lint:fix": "npm run lint -- --fix"
    },
    "engines": {
      "node": ">=10.16.0"
    },
    "keywords": [
      "uploads",
      "forms",
      "multipart",
      "form-data"
    ],
    "licenses": [
      {
        "type": "MIT",
        "url": "http://github.com/mscdex/busboy/raw/master/LICENSE"
      }
    ],
    "repository": {
      "type": "git",
      "url": "http://github.com/mscdex/busboy.git"
    },
    "_registry": "npm",
    "_loc": "/home/node/.cache/yarn/v6/npm-busboy-1.6.0-966ea36a9502e43cdb9146962523b92f531f6893-integrity/node_modules/busboy/package.json",
    "readmeFilename": "README.md",
    "readme": "# Description\n\nA node.js module for parsing incoming HTML form data.\n\nChanges (breaking or otherwise) in v1.0.0 can be found [here](https://github.com/mscdex/busboy/issues/266).\n\n# Requirements\n\n* [node.js](http://nodejs.org/) -- v10.16.0 or newer\n\n\n# Install\n\n    npm install busboy\n\n\n# Examples\n\n* Parsing (multipart) with default options:\n\n```js\nconst http = require('http');\n\nconst busboy = require('busboy');\n\nhttp.createServer((req, res) => {\n  if (req.method === 'POST') {\n    console.log('POST request');\n    const bb = busboy({ headers: req.headers });\n    bb.on('file', (name, file, info) => {\n      const { filename, encoding, mimeType } = info;\n      console.log(\n        `File [${name}]: filename: %j, encoding: %j, mimeType: %j`,\n        filename,\n        encoding,\n        mimeType\n      );\n      file.on('data', (data) => {\n        console.log(`File [${name}] got ${data.length} bytes`);\n      }).on('close', () => {\n        console.log(`File [${name}] done`);\n      });\n    });\n    bb.on('field', (name, val, info) => {\n      console.log(`Field [${name}]: value: %j`, val);\n    });\n    bb.on('close', () => {\n      console.log('Done parsing form!');\n      res.writeHead(303, { Connection: 'close', Location: '/' });\n      res.end();\n    });\n    req.pipe(bb);\n  } else if (req.method === 'GET') {\n    res.writeHead(200, { Connection: 'close' });\n    res.end(`\n      <html>\n        <head></head>\n        <body>\n          <form method=\"POST\" enctype=\"multipart/form-data\">\n            <input type=\"file\" name=\"filefield\"><br />\n            <input type=\"text\" name=\"textfield\"><br />\n            <input type=\"submit\">\n          </form>\n        </body>\n      </html>\n    `);\n  }\n}).listen(8000, () => {\n  console.log('Listening for requests');\n});\n\n// Example output:\n//\n// Listening for requests\n//   < ... form submitted ... >\n// POST request\n// File [filefield]: filename: \"logo.jpg\", encoding: \"binary\", mime: \"image/jpeg\"\n// File [filefield] got 11912 bytes\n// Field [textfield]: value: \"testing! :-)\"\n// File [filefield] done\n// Done parsing form!\n```\n\n* Save all incoming files to disk:\n\n```js\nconst { randomFillSync } = require('crypto');\nconst fs = require('fs');\nconst http = require('http');\nconst os = require('os');\nconst path = require('path');\n\nconst busboy = require('busboy');\n\nconst random = (() => {\n  const buf = Buffer.alloc(16);\n  return () => randomFillSync(buf).toString('hex');\n})();\n\nhttp.createServer((req, res) => {\n  if (req.method === 'POST') {\n    const bb = busboy({ headers: req.headers });\n    bb.on('file', (name, file, info) => {\n      const saveTo = path.join(os.tmpdir(), `busboy-upload-${random()}`);\n      file.pipe(fs.createWriteStream(saveTo));\n    });\n    bb.on('close', () => {\n      res.writeHead(200, { 'Connection': 'close' });\n      res.end(`That's all folks!`);\n    });\n    req.pipe(bb);\n    return;\n  }\n  res.writeHead(404);\n  res.end();\n}).listen(8000, () => {\n  console.log('Listening for requests');\n});\n```\n\n\n# API\n\n## Exports\n\n`busboy` exports a single function:\n\n**( _function_ )**(< _object_ >config) - Creates and returns a new _Writable_ form parser stream.\n\n* Valid `config` properties:\n\n    * **headers** - _object_ - These are the HTTP headers of the incoming request, which are used by individual parsers.\n\n    * **highWaterMark** - _integer_ - highWaterMark to use for the parser stream. **Default:** node's _stream.Writable_ default.\n\n    * **fileHwm** - _integer_ - highWaterMark to use for individual file streams. **Default:** node's _stream.Readable_ default.\n\n    * **defCharset** - _string_ - Default character set to use when one isn't defined. **Default:** `'utf8'`.\n\n    * **defParamCharset** - _string_ - For multipart forms, the default character set to use for values of part header parameters (e.g. filename) that are not extended parameters (that contain an explicit charset). **Default:** `'latin1'`.\n\n    * **preservePath** - _boolean_ - If paths in filenames from file parts in a `'multipart/form-data'` request shall be preserved. **Default:** `false`.\n\n    * **limits** - _object_ - Various limits on incoming data. Valid properties are:\n\n        * **fieldNameSize** - _integer_ - Max field name size (in bytes). **Default:** `100`.\n\n        * **fieldSize** - _integer_ - Max field value size (in bytes). **Default:** `1048576` (1MB).\n\n        * **fields** - _integer_ - Max number of non-file fields. **Default:** `Infinity`.\n\n        * **fileSize** - _integer_ - For multipart forms, the max file size (in bytes). **Default:** `Infinity`.\n\n        * **files** - _integer_ - For multipart forms, the max number of file fields. **Default:** `Infinity`.\n\n        * **parts** - _integer_ - For multipart forms, the max number of parts (fields + files). **Default:** `Infinity`.\n\n        * **headerPairs** - _integer_ - For multipart forms, the max number of header key-value pairs to parse. **Default:** `2000` (same as node's http module).\n\nThis function can throw exceptions if there is something wrong with the values in `config`. For example, if the Content-Type in `headers` is missing entirely, is not a supported type, or is missing the boundary for `'multipart/form-data'` requests.\n\n## (Special) Parser stream events\n\n* **file**(< _string_ >name, < _Readable_ >stream, < _object_ >info) - Emitted for each new file found. `name` contains the form field name. `stream` is a _Readable_ stream containing the file's data. No transformations/conversions (e.g. base64 to raw binary) are done on the file's data. `info` contains the following properties:\n\n    * `filename` - _string_ - If supplied, this contains the file's filename. **WARNING:** You should almost _never_ use this value as-is (especially if you are using `preservePath: true` in your `config`) as it could contain malicious input. You are better off generating your own (safe) filenames, or at the very least using a hash of the filename.\n\n    * `encoding` - _string_ - The file's `'Content-Transfer-Encoding'` value.\n\n    * `mimeType` - _string_ - The file's `'Content-Type'` value.\n\n    **Note:** If you listen for this event, you should always consume the `stream` whether you care about its contents or not (you can simply do `stream.resume();` if you want to discard/skip the contents), otherwise the `'finish'`/`'close'` event will never fire on the busboy parser stream.\n    However, if you aren't accepting files, you can either simply not listen for the `'file'` event at all or set `limits.files` to `0`, and any/all files will be automatically skipped (these skipped files will still count towards any configured `limits.files` and `limits.parts` limits though).\n\n    **Note:** If a configured `limits.fileSize` limit was reached for a file, `stream` will both have a boolean property `truncated` set to `true` (best checked at the end of the stream) and emit a `'limit'` event to notify you when this happens.\n\n* **field**(< _string_ >name, < _string_ >value, < _object_ >info) - Emitted for each new non-file field found. `name` contains the form field name. `value` contains the string value of the field. `info` contains the following properties:\n\n    * `nameTruncated` - _boolean_ - Whether `name` was truncated or not (due to a configured `limits.fieldNameSize` limit)\n\n    * `valueTruncated` - _boolean_ - Whether `value` was truncated or not (due to a configured `limits.fieldSize` limit)\n\n    * `encoding` - _string_ - The field's `'Content-Transfer-Encoding'` value.\n\n    * `mimeType` - _string_ - The field's `'Content-Type'` value.\n\n* **partsLimit**() - Emitted when the configured `limits.parts` limit has been reached. No more `'file'` or `'field'` events will be emitted.\n\n* **filesLimit**() - Emitted when the configured `limits.files` limit has been reached. No more `'file'` events will be emitted.\n\n* **fieldsLimit**() - Emitted when the configured `limits.fields` limit has been reached. No more `'field'` events will be emitted.\n",
    "license": "MIT",
    "licenseText": "Copyright Brian White. All rights reserved.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to\ndeal in the Software without restriction, including without limitation the\nrights to use, copy, modify, merge, publish, distribute, sublicense, and/or\nsell copies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\nIN THE SOFTWARE."
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.yarnpkg.com/busboy/-/busboy-1.6.0.tgz#966ea36a9502e43cdb9146962523b92f531f6893",
    "type": "tarball",
    "reference": "https://registry.yarnpkg.com/busboy/-/busboy-1.6.0.tgz",
    "hash": "966ea36a9502e43cdb9146962523b92f531f6893",
    "integrity": "sha512-8SFQbg/0hQ9xy3UNTB0YEnsNBbWfhf7RtnzpL7TkBiTBRfrQ9Fxcnz7VJsleJpyp6rVLvXiuORqjlHi5q+PYuA==",
    "registry": "npm",
    "packageName": "busboy",
    "cacheIntegrity": "sha512-8SFQbg/0hQ9xy3UNTB0YEnsNBbWfhf7RtnzpL7TkBiTBRfrQ9Fxcnz7VJsleJpyp6rVLvXiuORqjlHi5q+PYuA== sha1-lm6japUC5DzbkUaWJSO5L1MfaJM="
  },
  "registry": "npm",
  "hash": "966ea36a9502e43cdb9146962523b92f531f6893"
}