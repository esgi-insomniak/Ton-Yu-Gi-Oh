{
  "manifest": {
    "name": "@sinclair/typebox",
    "version": "0.25.23",
    "description": "JSONSchema Type Builder with Static Type Resolution for TypeScript",
    "keywords": [
      "typescript",
      "json-schema",
      "validate",
      "typecheck"
    ],
    "author": {
      "name": "sinclairzx81"
    },
    "license": "MIT",
    "main": "./typebox.js",
    "types": "./typebox.d.ts",
    "exports": {
      "./compiler": "./compiler/index.js",
      "./conditional": "./conditional/index.js",
      "./custom": "./custom/index.js",
      "./errors": "./errors/index.js",
      "./format": "./format/index.js",
      "./guard": "./guard/index.js",
      "./hash": "./hash/index.js",
      "./system": "./system/index.js",
      "./value": "./value/index.js",
      ".": "./typebox.js"
    },
    "repository": {
      "type": "git",
      "url": "https://github.com/sinclairzx81/typebox"
    },
    "scripts": {
      "clean": "hammer task clean",
      "format": "hammer task format",
      "start": "hammer task start",
      "test": "hammer task test",
      "benchmark": "hammer task benchmark",
      "build": "hammer task build",
      "publish": "hammer task publish"
    },
    "devDependencies": {
      "@sinclair/hammer": "^0.17.1",
      "@types/chai": "^4.3.3",
      "@types/mocha": "^9.1.1",
      "@types/node": "^18.11.9",
      "ajv": "^8.11.2",
      "ajv-formats": "^2.1.1",
      "chai": "^4.3.6",
      "mocha": "^9.2.2",
      "prettier": "^2.7.1",
      "typescript": "^4.9.3"
    },
    "_registry": "npm",
    "_loc": "/home/node/.cache/yarn/v6/npm-@sinclair-typebox-0.25.23-1c15b0d2b872d89cc0f47c7243eacb447df8b8bd-integrity/node_modules/@sinclair/typebox/package.json",
    "readmeFilename": "readme.md",
    "readme": "<div align='center'>\n\n<h1>TypeBox</h1>\n\n<p>JSON Schema Type Builder with Static Type Resolution for TypeScript</p>\n\t\n<img src=\"https://github.com/sinclairzx81/typebox/blob/master/typebox.png?raw=true\" />\n\n<br />\n<br />\n\n[![npm version](https://badge.fury.io/js/%40sinclair%2Ftypebox.svg)](https://badge.fury.io/js/%40sinclair%2Ftypebox)\n[![Downloads](https://img.shields.io/npm/dm/%40sinclair%2Ftypebox.svg)](https://www.npmjs.com/package/%40sinclair%2Ftypebox)\n[![GitHub CI](https://github.com/sinclairzx81/typebox/workflows/GitHub%20CI/badge.svg)](https://github.com/sinclairzx81/typebox/actions)\n\n</div>\n\n<a name=\"Install\"></a>\n\n## Install\n\n### npm\n```bash\n$ npm install @sinclair/typebox --save\n```\n\n### deno\n```typescript\nimport { Static, Type } from 'npm:@sinclair/typebox'\n```\n\n### esm\n\n```typescript\nimport { Static, Type } from 'https://esm.sh/@sinclair/typebox'\n```\n\n## Usage\n\n```typescript\nimport { Static, Type } from '@sinclair/typebox'\n\nconst T = Type.Object({                              // const T = {\n  x: Type.Number(),                                  //   type: 'object',\n  y: Type.Number(),                                  //   required: ['x', 'y', 'z'],\n  z: Type.Number()                                   //   properties: {\n})                                                   //     x: { type: 'number' },\n                                                     //     y: { type: 'number' },\n                                                     //     z: { type: 'number' }\n                                                     //   }\n                                                     // }\n\ntype T = Static<typeof T>                            // type T = {\n                                                     //   x: number,\n                                                     //   y: number,\n                                                     //   z: number\n                                                     // }\n```\n\n\n<a name=\"Overview\"></a>\n\n## Overview\n\nTypeBox is a type builder library that creates in-memory JSON Schema objects that can be statically inferred as TypeScript types. The schemas produced by this library are designed to match the static type checking rules of the TypeScript compiler. TypeBox enables one to create a unified type that can be statically checked by TypeScript and runtime asserted using standard JSON Schema validation.\n\nTypeBox is designed to enable JSON schema to compose with the same flexibility as TypeScript's type system. It can be used either as a simple tool to build up complex schemas or integrated into REST and RPC services to help validate data received over the wire. \n\nLicense MIT\n\n## Contents\n- [Install](#install)\n- [Overview](#overview)\n- [Example](#Example)\n- [Types](#types)\n  - [Standard](#types-standard)\n  - [Extended](#types-extended)\n  - [Modifiers](#types-modifiers)\n  - [Options](#types-options)\n  - [Reference](#types-reference)\n  - [Recursive](#types-recursive)\n  - [Generic](#types-generic)\n  - [Conditional](#types-conditional)\n  - [Unsafe](#types-unsafe)\n  - [Guards](#types-guards)\n  - [Strict](#types-strict)\n- [Values](#values)\n  - [Create](#values-create)\n  - [Clone](#values-clone)\n  - [Check](#values-check)\n  - [Cast](#values-cast)\n  - [Equal](#values-equal)\n  - [Hash](#values-hash)\n  - [Diff](#values-diff)\n  - [Patch](#values-patch)\n  - [Errors](#values-errors)\n  - [Pointer](#values-pointer)\n- [TypeCheck](#typecheck)\n  - [TypeCompiler](#typecheck-typecompiler)\n  - [Ajv](#typecheck-ajv)\n- [TypeSystem](#typecheck)\n  - [Types](#typesystem-types)\n  - [Formats](#typesystem-formats)\n- [Benchmark](#benchmark)\n  - [Compile](#benchmark-compile)\n  - [Validate](#benchmark-validate)\n  - [Compression](#benchmark-compression)\n- [Contribute](#contribute)\n\n<a name=\"Example\"></a>\n\n## Example\n\nThe following demonstrates TypeBox's general usage.\n\n```typescript\n\nimport { Static, Type } from '@sinclair/typebox'\n\n//--------------------------------------------------------------------------------------------\n//\n// Let's say you have the following type ...\n//\n//--------------------------------------------------------------------------------------------\n\ntype T = {\n  id: string,\n  name: string,\n  timestamp: number\n}\n\n//--------------------------------------------------------------------------------------------\n//\n// ... you can express this type in the following way.\n//\n//--------------------------------------------------------------------------------------------\n\nconst T = Type.Object({                              // const T = {\n  id: Type.String(),                                 //   type: 'object',\n  name: Type.String(),                               //   properties: { \n  timestamp: Type.Integer()                          //     id: { \n})                                                   //       type: 'string' \n                                                     //     },\n                                                     //     name: { \n                                                     //       type: 'string' \n                                                     //     },\n                                                     //     timestamp: { \n                                                     //       type: 'integer' \n                                                     //     }\n                                                     //   }, \n                                                     //   required: [\n                                                     //     'id',\n                                                     //     'name',\n                                                     //     'timestamp'\n                                                     //   ]\n                                                     // } \n\n//--------------------------------------------------------------------------------------------\n//\n// ... then infer back to the original static type this way.\n//\n//--------------------------------------------------------------------------------------------\n\ntype T = Static<typeof T>                            // type T = {\n                                                     //   id: string,\n                                                     //   name: string,\n                                                     //   timestamp: number\n                                                     // }\n\n//--------------------------------------------------------------------------------------------\n//\n// ... then use the type both as JSON schema and as a TypeScript type.\n//\n//--------------------------------------------------------------------------------------------\n\nfunction receive(value: T) {                         // ... as a Type\n\n  if(JSON.validate(T, value)) {                      // ... as a Schema\n  \n    // ok...\n  }\n}\n```\n\n<a name='types'></a>\n\n## Types\n\nTypeBox provides a set of functions that allow you to compose JSON Schema similar to how you would compose static types with TypeScript. Each function creates a JSON schema fragment which can compose into more complex types. The schemas produced by TypeBox can be passed directly to any JSON Schema compliant validator, or used to reflect runtime metadata for a type.\n\n<a name='types-standard'></a>\n\n### Standard\n\nThe following table lists the Standard TypeBox types.\n\n```typescript\n┌────────────────────────────────┬─────────────────────────────┬────────────────────────────────┐\n│ TypeBox                        │ TypeScript                  │ JSON Schema                    │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Any()           │ type T = any                │ const T = { }                  │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Unknown()       │ type T = unknown            │ const T = { }                  │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.String()        │ type T = string             │ const T = {                    │\n│                                │                             │   type: 'string'               │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Number()        │ type T = number             │ const T = {                    │\n│                                │                             │   type: 'number'               │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Integer()       │ type T = number             │ const T = {                    │\n│                                │                             │   type: 'integer'              │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Boolean()       │ type T = boolean            │ const T = {                    │\n│                                │                             │   type: 'boolean'              │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Null()          │ type T = null               │ const T = {                    │\n│                                │                             │    type: 'null'                │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.RegEx(/foo/)    │ type T = string             │ const T = {                    │\n│                                │                             │    type: 'string',             │\n│                                │                             │    pattern: 'foo'              │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Literal(42)     │ type T = 42                 │ const T = {                    │\n│                                │                             │    const: 42,                  │\n│                                │                             │    type: 'number'              │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Array(          │ type T = number[]           │ const T = {                    │\n│   Type.Number()                │                             │   type: 'array',               │\n│ )                              │                             │   items: {                     │\n│                                │                             │     type: 'number'             │\n│                                │                             │   }                            │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Object({        │ type T = {                  │ const T = {                    │\n│   x: Type.Number(),            │   x: number,                │   type: 'object',              │\n│   y: Type.Number()             │   y: number                 │   properties: {                │\n│ })                             │ }                           │      x: {                      │\n│                                │                             │        type: 'number'          │\n│                                │                             │      },                        │\n│                                │                             │      y: {                      │\n│                                │                             │        type: 'number'          │\n│                                │                             │      }                         │\n│                                │                             │   },                           │\n│                                │                             │   required: ['x', 'y']         │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Tuple([         │ type T = [number, number]   │ const T = {                    │\n│   Type.Number(),               │                             │   type: 'array',               │\n│   Type.Number()                │                             │   items: [{                    │\n│ ])                             │                             │      type: 'number'            │\n│                                │                             │    }, {                        │\n│                                │                             │      type: 'number'            │\n│                                │                             │    }],                         │\n│                                │                             │    additionalItems: false,     │\n│                                │                             │    minItems: 2,                │\n│                                │                             │    maxItems: 2                 │\n│                                │                             │ }                              │\n│                                │                             │                                │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ enum Foo {                     │ enum Foo {                  │ const T = {                    │\n│   A,                           │   A,                        │   anyOf: [{                    │\n│   B                            │   B                         │     type: 'number',            │\n│ }                              │ }                           │     const: 0                   │\n│                                │                             │   }, {                         │\n│ const T = Type.Enum(Foo)       │ type T = Foo                │     type: 'number',            │\n│                                │                             │     const: 1                   │\n│                                │                             │   }]                           │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.KeyOf(          │ type T = keyof {            │ const T = {                    │\n│   Type.Object({                │   x: number,                │   anyOf: [{                    │\n│     x: Type.Number(),          │   y: number                 │     type: 'string',            │\n│     y: Type.Number()           │ }                           │     const: 'x'                 │\n│   })                           │                             │   }, {                         │\n│ )                              │                             │     type: 'string',            │\n│                                │                             │     const: 'y'                 │\n│                                │                             │   }]                           │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Union([         │ type T = string | number    │ const T = {                    │\n│   Type.String(),               │                             │   anyOf: [{                    │\n│   Type.Number()                │                             │      type: 'string'            │\n│ ])                             │                             │   }, {                         │\n│                                │                             │      type: 'number'            │\n│                                │                             │   }]                           │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Intersect([     │ type T = {                  │ const T = {                    │\n│   Type.Object({                │   x: number                 │   type: 'object',              │\n│     x: Type.Number()           │ } & {                       │   properties: {                │\n│   }),                          │   y: number                 │     x: {                       │\n│   Type.Object({                │ }                           │       type: 'number'           │\n│     y: Type.Number()           │                             │     },                         │\n│   })                           │                             │     y: {                       │\n│ ])                             │                             │       type: 'number'           │\n│                                │                             │     }                          │\n│                                │                             │   },                           │\n│                                │                             │   required: ['x', 'y']         │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Never()         │ type T = never              │ const T = {                    │\n│                                │                             │   allOf: [{                    │\n│                                │                             │     type: 'boolean',           │\n│                                │                             │     const: false               │\n│                                │                             │   }, {                         │\n│                                │                             │     type: 'boolean',           │\n│                                │                             │     const: true                │\n│                                │                             │   }]                           │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Record(         │ type T = Record<            │ const T = {                    │\n│   Type.String(),               │   string,                   │   type: 'object',              │\n│   Type.Number()                │   number,                   │   patternProperties: {         │\n│ )                              │ >                           │     '^.*$': {                  │\n│                                │                             │       type: 'number'           │\n│                                │                             │     }                          │\n│                                │                             │   }                            │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Partial(        │ type T = Partial<{          │ const T = {                    │\n│   Type.Object({                │   x: number,                │   type: 'object',              │\n│     x: Type.Number(),          │   y: number                 │   properties: {                │\n│     y: Type.Number()           | }>                          │     x: {                       │\n│   })                           │                             │       type: 'number'           │\n│ )                              │                             │     },                         │\n│                                │                             │     y: {                       │\n│                                │                             │       type: 'number'           │\n│                                │                             │     }                          │\n│                                │                             │   }                            │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Required(       │ type T = Required<{         │ const T = {                    │\n│   Type.Object({                │   x?: number,               │   type: 'object',              │\n│     x: Type.Optional(          │   y?: number                │   properties: {                │\n│       Type.Number()            | }>                          │     x: {                       │\n│     ),                         │                             │       type: 'number'           │\n│     y: Type.Optional(          │                             │     },                         │\n│       Type.Number()            │                             │     y: {                       │\n│     )                          │                             │       type: 'number'           │\n│   })                           │                             │     }                          │\n│ )                              │                             │   },                           │\n│                                │                             │   required: ['x', 'y']         │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Pick(           │ type T = Pick<{             │ const T = {                    │\n│   Type.Object({                │   x: number,                │   type: 'object',              │\n│     x: Type.Number(),          │   y: number                 │   properties: {                │\n│     y: Type.Number()           | }, 'x'>                     │     x: {                       │\n│   }), ['x']                    │                             │       type: 'number'           │\n│ )                              │                             │     }                          │\n│                                │                             │   },                           │\n│                                │                             │   required: ['x']              │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Omit(           │ type T = Omit<{             │ const T = {                    │\n│   Type.Object({                │   x: number,                │   type: 'object',              │\n│     x: Type.Number(),          │   y: number                 │   properties: {                │\n│     y: Type.Number()           | }, 'x'>                     │     y: {                       │\n│   }), ['x']                    │                             │       type: 'number'           │\n│ )                              │                             │     }                          │\n│                                │                             │   },                           │\n│                                │                             │   required: ['y']              │\n│                                │                             │ }                              │\n│                                │                             │                                │\n└────────────────────────────────┴─────────────────────────────┴────────────────────────────────┘\n```\n\n<a name='types-extended'></a>\n\n### Extended\n\nTypeBox provides a set of extended types that can be used to express schematics for core JavaScript constructs and primitives. Extended types are not valid JSON Schema and will not validate using typical validation. These types however can be used to frame JSON schema and describe callable RPC interfaces that may receive JSON validated data.\n\n```typescript\n┌────────────────────────────────┬─────────────────────────────┬────────────────────────────────┐\n│ TypeBox                        │ TypeScript                  │ Extended Schema                │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Constructor([   │ type T = new (              │ const T = {                    │\n│   Type.String(),               │  arg0: string,              │   type: 'object',              │\n│   Type.Number()                │  arg1: number               │   instanceOf: 'Constructor',   │\n│ ], Type.Boolean())             │ ) => boolean                │   parameters: [{               │\n│                                │                             │     type: 'string'             │\n│                                │                             │   }, {                         │\n│                                │                             │     type: 'number'             │\n│                                │                             │   }],                          │\n│                                │                             │   return: {                    │\n│                                │                             │     type: 'boolean'            │\n│                                │                             │   }                            │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Function([      │ type T = (                  │ const T = {                    │\n|   Type.String(),               │  arg0: string,              │   type : 'object',             │\n│   Type.Number()                │  arg1: number               │   instanceOf: 'Function',      │\n│ ], Type.Boolean())             │ ) => boolean                │   parameters: [{               │\n│                                │                             │     type: 'string'             │\n│                                │                             │   }, {                         │\n│                                │                             │     type: 'number'             │\n│                                │                             │   }],                          │\n│                                │                             │   return: {                    │\n│                                │                             │     type: 'boolean'            │\n│                                │                             │   }                            │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Promise(        │ type T = Promise<string>    │ const T = {                    │\n│   Type.String()                │                             │   type: 'object',              │\n│ )                              │                             │   instanceOf: 'Promise',       │\n│                                │                             │   item: {                      │\n│                                │                             │     type: 'string'             │\n│                                │                             │   }                            │\n│                                │                             │ }                              │\n│                                │                             │                                │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Uint8Array()    │ type T = Uint8Array         │ const T = {                    │\n│                                │                             │   type: 'object',              │\n│                                │                             │   instanceOf: 'Uint8Array'     │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Date()          │ type T = Date               │ const T = {                    │\n│                                │                             │   type: 'object',              │\n│                                │                             │   instanceOf: 'Date'           │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Undefined()     │ type T = undefined          │ const T = {                    │\n│                                │                             │   type: 'null',                │\n│                                │                             │   typeOf: 'Undefined'          │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Void()          │ type T = void               │ const T = {                    │\n│                                │                             │   type: 'null'                 │\n│                                │                             │   typeOf: 'Void'               │\n│                                │                             │ }                              │\n│                                │                             │                                │\n└────────────────────────────────┴─────────────────────────────┴────────────────────────────────┘\n```\n\n<a name='types-modifiers'></a>\n\n### Modifiers\n\nTypeBox provides modifiers that can be applied to an objects properties. This allows for `optional` and `readonly` to be applied to that property. The following table illustates how they map between TypeScript and JSON Schema.\n\n```typescript\n┌────────────────────────────────┬─────────────────────────────┬────────────────────────────────┐\n│ TypeBox                        │ TypeScript                  │ JSON Schema                    │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Object({        │ type T = {                  │ const T = {                    │\n│   name: Type.Optional(         │   name?: string             │   type: 'object',              │\n│     Type.String()              │ }                           │   properties: {                │\n│   )                            │                             │      name: {                   │\n│ })  \t                         │                             │        type: 'string'          │\n│                                │                             │      }                         │\n│                                │                             │   }                            │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Object({        │ type T = {                  │ const T = {                    │\n│   name: Type.Readonly(         │   readonly name: string     │   type: 'object',              │\n│     Type.String()              │ }                           │   properties: {                │\n│   )                            │                             │     name: {                    │\n│ })  \t                         │                             │       type: 'string'           │\n│                                │                             │     }                          │\n│                                │                             │   },                           │\n│                                │                             │   required: ['name']           │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Object({        │ type T = {                  │ const T = {                    │\n│   name: Type.ReadonlyOptional( │   readonly name?: string    │   type: 'object',              │\n│     Type.String()              │ }                           │   properties: {                │\n│   )                            │                             │     name: {                    │\n│ })  \t                         │                             │       type: 'string'           │\n│                                │                             │     }                          │\n│                                │                             │   }                            │\n│                                │                             │ }                              │\n│                                │                             │                                │\n└────────────────────────────────┴─────────────────────────────┴────────────────────────────────┘\n```\n\n<a name='types-options'></a>\n\n### Options\n\nYou can pass additional JSON schema options on the last argument of any given type. The following are some examples.\n\n```typescript\n// string must be an email\nconst T = Type.String({ format: 'email' })\n\n// number must be a multiple of 2\nconst T = Type.Number({ multipleOf: 2 })\n\n// array must have at least 5 integer values\nconst T = Type.Array(Type.Integer(), { minItems: 5 })\n```\n\n<a name='types-reference'></a>\n\n### Reference\n\nUse `Type.Ref(...)` to create referenced types. The target type must specify an `$id`.\n\n```typescript\nconst T = Type.String({ $id: 'T' })                  // const T = {\n                                                     //    $id: 'T',\n                                                     //    type: 'string'\n                                                     // }\n                                             \nconst R = Type.Ref(T)                                // const R = {\n                                                     //    $ref: 'T'\n                                                     // }\n```\n\n<a name='types-recursive'></a>\n\n### Recursive\n\nUse `Type.Recursive(...)` to create recursive types.\n\n```typescript\nconst Node = Type.Recursive(Node => Type.Object({    // const Node = {\n  id: Type.String(),                                 //   $id: 'Node',\n  nodes: Type.Array(Node)                            //   type: 'object',\n}), { $id: 'Node' })                                 //   properties: {\n                                                     //     id: {\n                                                     //       type: 'string'\n                                                     //     },\n                                                     //     nodes: {\n                                                     //       type: 'array',\n                                                     //       items: {\n                                                     //         $ref: 'Node'\n                                                     //       }\n                                                     //     }\n                                                     //   },\n                                                     //   required: [\n                                                     //     'id',\n                                                     //     'nodes'\n                                                     //   ]\n                                                     // }\n\ntype Node = Static<typeof Node>                      // type Node = {\n                                                     //   id: string\n                                                     //   nodes: Node[]\n                                                     // }\n\nfunction test(node: Node) {\n  const id = node.nodes[0].nodes[0]                  // id is string\n                 .nodes[0].nodes[0]\n                 .id\n}\n```\n\n<a name='types-generic'></a>\n\n### Generic\n\nUse functions to create generic types. The following creates a generic `Nullable<T>` type. \n\n```typescript\nimport { Type, Static, TSchema } from '@sinclair/typebox'\n\nconst Nullable = <T extends TSchema>(type: T) => Type.Union([type, Type.Null()])\n\nconst T = Nullable(Type.String())                    // const T = {\n                                                     //   anyOf: [{\n                                                     //     type: 'string'\n                                                     //   }, {\n                                                     //     type: 'null'\n                                                     //   }]\n                                                     // }\n\ntype T = Static<typeof T>                            // type T = string | null\n\nconst U = Nullable(Type.Number())                    // const U = {\n                                                     //   anyOf: [{\n                                                     //     type: 'number'\n                                                     //   }, {\n                                                     //     type: 'null'\n                                                     //   }]\n                                                     // }\n\ntype U = Static<typeof U>                            // type U = number | null\n```\n\n<a name='types-conditional'></a>\n\n### Conditional\n\nUse the conditional module to create [Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html). This module implements TypeScript's structural equivalence checks to enable TypeBox types to be conditionally inferred at runtime. This module also provides the [Extract](https://www.typescriptlang.org/docs/handbook/utility-types.html#extracttype-union) and [Exclude](https://www.typescriptlang.org/docs/handbook/utility-types.html#excludeuniontype-excludedmembers) utility types which are expressed as conditional types in TypeScript. \n\nThe conditional module is provided as an optional import.\n\n```typescript\nimport { Conditional } from '@sinclair/typebox/conditional'\n```\nThe following table shows the TypeBox mappings between TypeScript and JSON schema.\n\n```typescript\n┌────────────────────────────────┬─────────────────────────────┬────────────────────────────────┐\n│ TypeBox                        │ TypeScript                  │ JSON Schema                    │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Conditional.Extends( │ type T =                    │ const T = {                    │\n│   Type.String(),               │  string extends number      │   const: false,                │\n│   Type.Number(),               │  true : false               │   type: 'boolean'              │\n│   Type.Literal(true),          │                             │ }                              │\n│   Type.Literal(false)          │                             │                                │\n│ )                              │                             │                                │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Conditional.Extract( │ type T = Extract<           │ const T = {                    │\n│   Type.Union([                 │   'a' | 'b' | 'c',          │   anyOf: [{                    │\n│     Type.Literal('a'),         │   'a' | 'f'                 │     const: 'a'                 │\n│     Type.Literal('b'),         │ >                           │     type: 'string'             │\n│     Type.Literal('c')          │                             │   }]                           │\n│   ]),                          │                             │ }                              │\n│   Type.Union([                 │                             │                                │\n│     Type.Literal('a'),         │                             │                                │\n│     Type.Literal('f')          │                             │                                │\n│   ])                           │                             │                                │\n│ )                              │                             │                                │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Conditional.Exclude( │ type T = Exclude<           │ const T = {                    │\n│   Type.Union([                 │   'a' | 'b' | 'c',          │   anyOf: [{                    │\n│     Type.Literal('a'),         │   'a'                       │     const: 'b',                │\n│     Type.Literal('b'),         │ >                           │     type: 'string'             │\n│     Type.Literal('c')          │                             │   }, {                         │\n│   ]),                          │                             │     const: 'c',                │\n│   Type.Union([                 │                             │     type: 'string'             │\n│     Type.Literal('a')          │                             │   }]                           │\n│   ])                           │                             │ }                              │\n│ )                              │                             │                                │\n│                                │                             │                                │\n└────────────────────────────────┴─────────────────────────────┴────────────────────────────────┘\n```\n\n<a name='types-unsafe'></a>\n\n### Unsafe\n\nUse `Type.Unsafe(...)` to create custom schemas with user defined inference rules.\n\n```typescript\nconst T = Type.Unsafe<string>({ type: 'number' })    // const T = {\n                                                     //   type: 'number'\n                                                     // }\n\ntype T = Static<typeof T>                            // type T = string\n```\n\nThis function can be used to create custom schemas for validators that require specific schema representations. An example of this might be OpenAPI's `nullable` and `enum` schemas which are not provided by TypeBox. The following demonstrates using `Type.Unsafe(...)` to create these types.\n\n```typescript\nimport { Type, Static, TSchema } from '@sinclair/typebox'\n\n//--------------------------------------------------------------------------------------------\n//\n// Nullable<T>\n//\n//--------------------------------------------------------------------------------------------\n\nfunction Nullable<T extends TSchema>(schema: T) {\n  return Type.Unsafe<Static<T> | null>({ ...schema, nullable: true })\n}\n\nconst T = Nullable(Type.String())                    // const T = {\n                                                     //   type: 'string',\n                                                     //   nullable: true\n                                                     // }\n\ntype T = Static<typeof T>                            // type T = string | null\n\n\n//--------------------------------------------------------------------------------------------\n//\n// StringEnum<string[]>\n//\n//--------------------------------------------------------------------------------------------\n\nfunction StringEnum<T extends string[]>(values: [...T]) {\n  return Type.Unsafe<T[number]>({ type: 'string', enum: values })\n}\n\nconst T = StringEnum(['A', 'B', 'C'])                // const T = {\n                                                     //   enum: ['A', 'B', 'C']\n                                                     // }\n\ntype T = Static<typeof T>                            // type T = 'A' | 'B' | 'C'\n```\n\n<a name='types-guards'></a>\n\n### Guards\n\nUse the guard module to test if values are TypeBox types.\n\n```typescript\nimport { TypeGuard } from '@sinclair/typebox/guard'\n\nconst T = Type.String()\n\nif(TypeGuard.TString(T)) {\n    \n  // T is TString\n}\n```\n\n<a name='types-strict'></a>\n\n### Strict\n\nTypeBox schemas contain the `Kind` and `Modifier` symbol properties. These properties are provided to enable runtime type reflection on schemas, as well as helping TypeBox internally compose types. These properties are not strictly valid JSON schema; so in some cases it may be desirable to omit them. TypeBox provides a `Type.Strict()` function that will omit these properties if necessary.\n\n```typescript\nconst T = Type.Object({                              // const T = {\n  name: Type.Optional(Type.String())                 //   [Kind]: 'Object',\n})                                                   //   type: 'object',\n                                                     //   properties: {\n                                                     //     name: {\n                                                     //       [Kind]: 'String',\n                                                     //       type: 'string',\n                                                     //       [Modifier]: 'Optional'\n                                                     //     }\n                                                     //   }\n                                                     // }\n\nconst U = Type.Strict(T)                             // const U = {\n                                                     //   type: 'object', \n                                                     //   properties: { \n                                                     //     name: { \n                                                     //       type: 'string' \n                                                     //     } \n                                                     //   } \n                                                     // }\n```\n\n<a name='values'></a>\n\n## Values\n\nTypeBox includes an optional values module that can be used to perform common operations on JavaScript values. This module enables one to create, check and cast values from types. It also provides functionality to check equality, clone and diff and patch JavaScript values. The value module is provided as an optional import.\n\n```typescript\nimport { Value } from '@sinclair/typebox/value'\n```\n\n<a name='values-create'></a>\n\n### Create\n\nUse the Create function to create a value from a TypeBox type. TypeBox will use default values if specified.\n\n```typescript\nconst T = Type.Object({ x: Type.Number(), y: Type.Number({ default: 42 }) })\n\nconst A = Value.Create(T)                            // const A = { x: 0, y: 42 }\n```\n\n<a name='values-clone'></a>\n\n### Clone\n\nUse the Clone function to deeply clone a value\n\n```typescript\nconst A = Value.Clone({ x: 1, y: 2, z: 3 })          // const A = { x: 1, y: 2, z: 3 }\n```\n\n<a name='values-check'></a>\n\n### Check\n\nUse the Check function to type check a value\n\n```typescript\nconst T = Type.Object({ x: Type.Number() })\n\nconst R = Value.Check(T, { x: 1 })                   // const R = true\n```\n\n<a name='values-cast'></a>\n\n### Cast\n\nUse the Cast function to cast a value into a type. The cast function will retain as much information as possible from the original value.\n\n```typescript\nconst T = Type.Object({ x: Type.Number(), y: Type.Number() }, { additionalProperties: false })\n\nconst X = Value.Cast(T, null)                        // const X = { x: 0, y: 0 }\n\nconst Y = Value.Cast(T, { x: 1 })                    // const Y = { x: 1, y: 0 }\n\nconst Z = Value.Cast(T, { x: 1, y: 2, z: 3 })        // const Z = { x: 1, y: 2 }\n```\n\n<a name='values-equal'></a>\n\n### Equal\n\nUse the Equal function to deeply check for value equality.\n\n```typescript\nconst R = Value.Equal(                               // const R = true\n  { x: 1, y: 2, z: 3 },\n  { x: 1, y: 2, z: 3 }\n)\n```\n\n<a name='values-hash'></a>\n\n### Hash\n\nUse the Hash function to create a [FNV1A-64](https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function) non cryptographic hash of a value.\n\n```typescript\nconst A = Value.Hash({ x: 1, y: 2, z: 3 })          // const A = 2910466848807138541n\n\nconst B = Value.Hash({ x: 1, y: 4, z: 3 })          // const B = 1418369778807423581n\n```\n\n<a name='values-diff'></a>\n\n### Diff\n\nUse the Diff function to produce a sequence of edits to transform one value into another.\n\n```typescript\nconst E = Value.Diff(                               // const E = [\n  { x: 1, y: 2, z: 3 },                             //   { type: 'update', path: '/y', value: 4 },\n  { y: 4, z: 5, w: 6 }                              //   { type: 'update', path: '/z', value: 5 },\n)                                                   //   { type: 'insert', path: '/w', value: 6 },\n                                                    //   { type: 'delete', path: '/x' }\n                                                    // ]\n```\n\n<a name='values-patch'></a>\n\n### Patch\n\nUse the Patch function to apply edits\n\n```typescript\nconst A = { x: 1, y: 2 }\n\nconst B = { x: 3 }\n\nconst E = Value.Diff(A, B)                           // const E = [\n                                                     //   { type: 'update', path: '/x', value: 3 },\n                                                     //   { type: 'delete', path: '/y' }\n                                                     // ]\n\nconst C = Value.Patch<typeof B>(A, E)                // const C = { x: 3 }\n```\n\n\n<a name='values-errors'></a>\n\n### Errors\n\nUse the Errors function enumerate validation errors.\n\n```typescript\nconst T = Type.Object({ x: Type.Number(), y: Type.Number() })\n\nconst R = [...Value.Errors(T, { x: '42' })]          // const R = [{\n                                                     //   schema: { type: 'number' },\n                                                     //   path: '/x',\n                                                     //   value: '42',\n                                                     //   message: 'Expected number'\n                                                     // }, {\n                                                     //   schema: { type: 'number' },\n                                                     //   path: '/y',\n                                                     //   value: undefined,\n                                                     //   message: 'Expected number'\n                                                     // }]\n```\n\n<a name='values-pointer'></a>\n\n### Pointer\n\nUse ValuePointer to perform mutable updates on existing values using [RFC6901](https://www.rfc-editor.org/rfc/rfc6901) Json Pointers.\n\n```typescript\nimport { ValuePointer } from '@sinclair/typebox/value'\n\nconst A = { x: 0, y: 0, z: 0 }\n\nValuePointer.Set(A, '/x', 1)                         // const A = { x: 1, y: 0, z: 0 }\nValuePointer.Set(A, '/y', 1)                         // const A = { x: 1, y: 1, z: 0 }\nValuePointer.Set(A, '/z', 1)                         // const A = { x: 1, y: 1, z: 1 }\n```\n<a name='typecheck'></a>\n\n## TypeCheck\n\nTypeBox targets JSON Schema Draft 6 and is built and tested against the Ajv JSON Schema validator for standards compliance. TypeBox also includes an optional built-in TypeCompiler that can provide improved compilation and validation performance specifically for TypeBox types only.\n\nThe following sections detail using these validators.\n\n<a name='typecheck-typecompiler'></a>\n\n### TypeCompiler\n\nTypeBox includes an high performance just-in-time (JIT) compiler and type checker that can be used in applications that require extremely fast validation. Note that this compiler is optimized for TypeBox types only where the schematics are known in advance.\n\nThe compiler module is provided as an optional import.\n\n```typescript\nimport { TypeCompiler } from '@sinclair/typebox/compiler'\n```\n\nUse the `Compile(...)` function to compile a type.\n\n```typescript\nconst C = TypeCompiler.Compile(Type.Object({         // const C: TypeCheck<TObject<{\n  x: Type.Number(),                                  //     x: TNumber;\n  y: Type.Number(),                                  //     y: TNumber;\n  z: Type.Number()                                   //     z: TNumber;\n}))                                                  // }>>\n\nconst R = C.Check({ x: 1, y: 2, z: 3 })              // const R = true\n```\n\nValidation errors can be read with the `Errors(...)` function.\n\n```typescript\nconst C = TypeCompiler.Compile(Type.Object({         // const C: TypeCheck<TObject<{\n  x: Type.Number(),                                  //     x: TNumber;\n  y: Type.Number(),                                  //     y: TNumber;\n  z: Type.Number()                                   //     z: TNumber;\n}))                                                  // }>>\n\nconst value = { }\n\nconst errors = [...C.Errors(value)]                  // const errors = [{\n                                                     //   schema: { type: 'number' },\n                                                     //   path: '/x',\n                                                     //   value: undefined,\n                                                     //   message: 'Expected number'\n                                                     // }, {\n                                                     //   schema: { type: 'number' },\n                                                     //   path: '/y',\n                                                     //   value: undefined,\n                                                     //   message: 'Expected number'\n                                                     // }, {\n                                                     //   schema: { type: 'number' },\n                                                     //   path: '/z',\n                                                     //   value: undefined,\n                                                     //   message: 'Expected number'\n                                                     // }]\n```\n\nCompiled routines can be inspected with the `.Code()` function.\n\n```typescript\nconst C = TypeCompiler.Compile(Type.String())        // const C: TypeCheck<TString>\n\nconsole.log(C.Code())                                // return function check(value) {\n                                                     //   return (\n                                                     //     (typeof value === 'string')\n                                                     //   )\n                                                     // }\n```\n\n<a name='typecheck-ajv'></a>\n\n### Ajv\n\nThe following are the recommended configurations to support both the [Standard](#standard) and [Extended](#extended) type sets provided by TypeBox. For schema portability and publishing to remote systems, it is recommended to use the Standard type set only.\n\n```bash\n$ npm install ajv ajv-formats --save\n```\n\n<details>\n\n<summary>\n<strong>Standard Ajv Configuration</strong>\n<p>Expand for Standard Type Set Configuration</p>\n</summary>\n\n```typescript\nimport { Type }   from '@sinclair/typebox'\nimport addFormats from 'ajv-formats'\nimport Ajv        from 'ajv'\n\nexport function createAjv() {\n  return addFormats(new Ajv({}), [\n    'date-time', \n    'time', \n    'date', \n    'email',  \n    'hostname', \n    'ipv4', \n    'ipv6', \n    'uri', \n    'uri-reference', \n    'uuid',\n    'uri-template', \n    'json-pointer', \n    'relative-json-pointer', \n    'regex'\n  ])\n}\n\nconst ajv = createAjv()\n\nconst R = ajv.validate(Type.Object({                 // const R = true\n  x: Type.Number(),\n  y: Type.Number(),\n  z: Type.Number()\n}), { x: 1, y: 2, z: 3 })     \n```\n\n</details>\n\n<details>\n\n<summary>\n<strong>Extended Ajv Configuration</strong>\n<p>Expand for Extended Type Set Configuration</p>\n</summary>\n\n```typescript\nimport { TypeGuard } from '@sinclair/typebox/guard'\nimport { Value }     from '@sinclair/typebox/value'\nimport { Type }      from '@sinclair/typebox'\nimport addFormats    from 'ajv-formats'\nimport Ajv           from 'ajv'\n\nfunction schemaOf(schemaOf: string, value: unknown, schema: unknown) {\n  switch (schemaOf) {\n    case 'Constructor':\n      return TypeGuard.TConstructor(schema) && Value.Check(schema, value) // not supported\n    case 'Function':\n      return TypeGuard.TFunction(schema) && Value.Check(schema, value) // not supported\n    case 'Date':\n      return TypeGuard.TDate(schema) && Value.Check(schema, value)\n    case 'Promise':\n      return TypeGuard.TPromise(schema) && Value.Check(schema, value) // not supported\n    case 'Uint8Array':\n      return TypeGuard.TUint8Array(schema) && Value.Check(schema, value)\n    case 'Undefined':\n      return TypeGuard.TUndefined(schema) && Value.Check(schema, value) // not supported\n    case 'Void':\n      return TypeGuard.TVoid(schema) && Value.Check(schema, value)\n    default:\n      return false\n  }\n}\n\nexport function createAjv() {\n  return addFormats(new Ajv({}), [\n    'date-time', \n    'time', \n    'date', \n    'email',  \n    'hostname', \n    'ipv4', \n    'ipv6', \n    'uri', \n    'uri-reference', \n    'uuid',\n    'uri-template', \n    'json-pointer', \n    'relative-json-pointer', \n    'regex'\n  ])\n  .addKeyword({ type: 'object', keyword: 'instanceOf', validate: schemaOf })\n  .addKeyword({ type: 'null', keyword: 'typeOf', validate: schemaOf })\n  .addKeyword('exclusiveMinimumTimestamp')\n  .addKeyword('exclusiveMaximumTimestamp')\n  .addKeyword('minimumTimestamp')\n  .addKeyword('maximumTimestamp')\n  .addKeyword('minByteLength')\n  .addKeyword('maxByteLength')\n}\n\nconst ajv = createAjv()\n\nconst R = ajv.validate(Type.Object({                 // const R = true\n  buffer: Type.Uint8Array(),\n  date: Type.Date(),\n  void: Type.Void()\n}), {\n  buffer: new Uint8Array(),\n  date: new Date(),\n  void: null\n})\n```\n\n</details>\n\n\n<a name='typesystem'></a>\n\n## TypeSystem\n\nTypeBox provides an extensible TypeSystem module that enables developers to register additional types above and beyond the standard or extended type set. This module also allows developers to define custom string formats as well as override certain type checking behaviours.\n\nThe TypeSystem module is provided as an optional import.\n\n```typescript\nimport { TypeSystem } from '@sinclair/typebox/system'\n```\n\n<a name='typesystem-types'></a>\n\n### Types\n\nUse the `CreateType(...)` function to specify and return a custom type. This function will return a type factory function that can be used to construct the type. The following creates and registers a BigNumber type which will statically infer as `bigint`.\n\n```typescript\n//--------------------------------------------------------------------------------------------\n//\n// Use TypeSystem.CreateType(...) to define and return a type factory function\n//\n//--------------------------------------------------------------------------------------------\n\ntype BigNumberOptions = { minimum?: bigint; maximum?: bigint }\n\nconst BigNumber = TypeSystem.CreateType<bigint, BigNumberOptions>(\n  'BigNumber', \n  (options, value) => {\n    if (typeof value !== 'bigint') return false\n    if (options.maximum !== undefined && value > options.maximum) return false\n    if (options.minimum !== undefined && value < options.minimum) return false\n    return true\n  }\n)\n\n//--------------------------------------------------------------------------------------------\n//\n// Use the custom type like any other type\n//\n//--------------------------------------------------------------------------------------------\n\nconst T = BigNumber({ minimum: 10n, maximum: 20n })  // const T = { \n                                                     //    minimum: 10n, \n                                                     //    maximum: 20n, \n                                                     //    [Symbol(TypeBox.Kind)]: 'BigNumber' \n                                                     //  }\n\nconst C = TypeCompiler.Compile(T)\nconst X = C.Check(15n)                               // const X = true\nconst Y = C.Check(5n)                                // const Y = false\nconst Z = C.Check(25n)                               // const Z = false\n```\n\n<a name='typesystem-formats'></a>\n\n### Formats\n\nUse the `CreateFormat(...)` function to specify user defined string formats. The following creates a custom string format that checks for lowercase.\n\n```typescript\n//--------------------------------------------------------------------------------------------\n//\n// Use TypeSystem.CreateFormat(...) to define a custom string format\n//\n//--------------------------------------------------------------------------------------------\n\nTypeSystem.CreateFormat('lowercase', value => value === value.toLowerCase())\n\n//--------------------------------------------------------------------------------------------\n//\n// Use the format by creating string types with the 'format' option\n//\n//--------------------------------------------------------------------------------------------\n\nconst T = Type.String({ format: 'lowercase' })\n\nconst A = Value.Check(T, 'action')                   // const A = true\n\nconst B = Value.Check(T, 'ACTION')                   // const B = false\n```\n\n<a name='benchmark'></a>\n\n## Benchmark\n\nThis project maintains a set of benchmarks that measure Ajv, Value and TypeCompiler compilation and validation performance. These benchmarks can be run locally by cloning this repository and running `npm run benchmark`. The results below show for Ajv version 8.11.2. \n\nFor additional comparative benchmarks, please refer to [typescript-runtime-type-benchmarks](https://moltar.github.io/typescript-runtime-type-benchmarks/).\n\n<a name='benchmark-compile'></a>\n\n### Compile\n\nThis benchmark measures compilation performance for varying types. You can review this benchmark [here](https://github.com/sinclairzx81/typebox/blob/master/benchmark/measurement/module/compile.ts).\n\n```typescript\n┌──────────────────┬────────────┬──────────────┬──────────────┬──────────────┐\n│     (index)      │ Iterations │     Ajv      │ TypeCompiler │ Performance  │\n├──────────────────┼────────────┼──────────────┼──────────────┼──────────────┤\n│           Number │    2000    │ '    418 ms' │ '     14 ms' │ '   29.86 x' │\n│           String │    2000    │ '    331 ms' │ '     12 ms' │ '   27.58 x' │\n│          Boolean │    2000    │ '    290 ms' │ '     13 ms' │ '   22.31 x' │\n│             Null │    2000    │ '    253 ms' │ '      8 ms' │ '   31.63 x' │\n│            RegEx │    2000    │ '    481 ms' │ '     18 ms' │ '   26.72 x' │\n│          ObjectA │    2000    │ '   2675 ms' │ '     54 ms' │ '   49.54 x' │\n│          ObjectB │    2000    │ '   2849 ms' │ '     39 ms' │ '   73.05 x' │\n│            Tuple │    2000    │ '   1224 ms' │ '     22 ms' │ '   55.64 x' │\n│            Union │    2000    │ '   1225 ms' │ '     26 ms' │ '   47.12 x' │\n│          Vector4 │    2000    │ '   1777 ms' │ '     24 ms' │ '   74.04 x' │\n│          Matrix4 │    2000    │ '    825 ms' │ '     12 ms' │ '   68.75 x' │\n│   Literal_String │    2000    │ '    345 ms' │ '      9 ms' │ '   38.33 x' │\n│   Literal_Number │    2000    │ '    363 ms' │ '      7 ms' │ '   51.86 x' │\n│  Literal_Boolean │    2000    │ '    358 ms' │ '      6 ms' │ '   59.67 x' │\n│     Array_Number │    2000    │ '    687 ms' │ '      8 ms' │ '   85.88 x' │\n│     Array_String │    2000    │ '    726 ms' │ '      8 ms' │ '   90.75 x' │\n│    Array_Boolean │    2000    │ '    703 ms' │ '      8 ms' │ '   87.88 x' │\n│    Array_ObjectA │    2000    │ '   3686 ms' │ '     40 ms' │ '   92.15 x' │\n│    Array_ObjectB │    2000    │ '   3821 ms' │ '     40 ms' │ '   95.53 x' │\n│      Array_Tuple │    2000    │ '   2070 ms' │ '     17 ms' │ '  121.76 x' │\n│      Array_Union │    2000    │ '   1503 ms' │ '     21 ms' │ '   71.57 x' │\n│    Array_Vector4 │    2000    │ '   2185 ms' │ '     21 ms' │ '  104.05 x' │\n│    Array_Matrix4 │    2000    │ '   1502 ms' │ '     16 ms' │ '   93.88 x' │\n└──────────────────┴────────────┴──────────────┴──────────────┴──────────────┘\n```\n\n<a name='benchmark-validate'></a>\n\n### Validate\n\nThis benchmark measures validation performance for varying types. You can review this benchmark [here](https://github.com/sinclairzx81/typebox/blob/master/benchmark/measurement/module/check.ts).\n\n```typescript\n┌──────────────────┬────────────┬──────────────┬──────────────┬──────────────┬──────────────┐\n│     (index)      │ Iterations │  ValueCheck  │     Ajv      │ TypeCompiler │ Performance  │\n├──────────────────┼────────────┼──────────────┼──────────────┼──────────────┼──────────────┤\n│           Number │  1000000   │ '     28 ms' │ '      6 ms' │ '      6 ms' │ '    1.00 x' │\n│           String │  1000000   │ '     25 ms' │ '     23 ms' │ '     11 ms' │ '    2.09 x' │\n│          Boolean │  1000000   │ '     24 ms' │ '     21 ms' │ '     11 ms' │ '    1.91 x' │\n│             Null │  1000000   │ '     25 ms' │ '     22 ms' │ '     10 ms' │ '    2.20 x' │\n│            RegEx │  1000000   │ '    164 ms' │ '     53 ms' │ '     37 ms' │ '    1.43 x' │\n│          ObjectA │  1000000   │ '    593 ms' │ '     47 ms' │ '     25 ms' │ '    1.88 x' │\n│          ObjectB │  1000000   │ '   1053 ms' │ '     54 ms' │ '     40 ms' │ '    1.35 x' │\n│            Tuple │  1000000   │ '    129 ms' │ '     25 ms' │ '     16 ms' │ '    1.56 x' │\n│            Union │  1000000   │ '    334 ms' │ '     25 ms' │ '     16 ms' │ '    1.56 x' │\n│        Recursive │  1000000   │ '   3127 ms' │ '    424 ms' │ '     98 ms' │ '    4.33 x' │\n│          Vector4 │  1000000   │ '    152 ms' │ '     24 ms' │ '     12 ms' │ '    2.00 x' │\n│          Matrix4 │  1000000   │ '    593 ms' │ '     41 ms' │ '     27 ms' │ '    1.52 x' │\n│   Literal_String │  1000000   │ '     48 ms' │ '     20 ms' │ '     11 ms' │ '    1.82 x' │\n│   Literal_Number │  1000000   │ '     47 ms' │ '     22 ms' │ '     10 ms' │ '    2.20 x' │\n│  Literal_Boolean │  1000000   │ '     48 ms' │ '     21 ms' │ '     11 ms' │ '    1.91 x' │\n│     Array_Number │  1000000   │ '    495 ms' │ '     32 ms' │ '     21 ms' │ '    1.52 x' │\n│     Array_String │  1000000   │ '    481 ms' │ '     31 ms' │ '     21 ms' │ '    1.48 x' │\n│    Array_Boolean │  1000000   │ '    446 ms' │ '     32 ms' │ '     27 ms' │ '    1.19 x' │\n│    Array_ObjectA │  1000000   │ '  14314 ms' │ '   2341 ms' │ '   1969 ms' │ '    1.19 x' │\n│    Array_ObjectB │  1000000   │ '  16883 ms' │ '   2661 ms' │ '   2606 ms' │ '    1.02 x' │\n│      Array_Tuple │  1000000   │ '   1834 ms' │ '     98 ms' │ '     77 ms' │ '    1.27 x' │\n│      Array_Union │  1000000   │ '   4960 ms' │ '    240 ms' │ '     87 ms' │ '    2.76 x' │\n│  Array_Recursive │  1000000   │ '  56273 ms' │ '   7118 ms' │ '   1122 ms' │ '    6.34 x' │\n│    Array_Vector4 │  1000000   │ '   2498 ms' │ '     99 ms' │ '     48 ms' │ '    2.06 x' │\n│    Array_Matrix4 │  1000000   │ '  12487 ms' │ '    383 ms' │ '    246 ms' │ '    1.56 x' │\n└──────────────────┴────────────┴──────────────┴──────────────┴──────────────┴──────────────┘\n```\n\n<a name='benchmark-compression'></a>\n\n### Compression\n\nThe following table lists esbuild compiled and minified sizes for each TypeBox module.\n\n```typescript\n┌──────────────────────┬────────────┬────────────┬─────────────┐\n│       (index)        │  Compiled  │  Minified  │ Compression │\n├──────────────────────┼────────────┼────────────┼─────────────┤\n│ typebox/compiler     │ '   64 kb' │ '   31 kb' │  '2.02 x'   │\n│ typebox/conditional  │ '   45 kb' │ '   18 kb' │  '2.44 x'   │\n│ typebox/custom       │ '    0 kb' │ '    0 kb' │  '2.61 x'   │\n│ typebox/format       │ '    0 kb' │ '    0 kb' │  '2.66 x'   │\n│ typebox/guard        │ '   23 kb' │ '   11 kb' │  '2.07 x'   │\n│ typebox/hash         │ '    4 kb' │ '    1 kb' │  '2.30 x'   │\n│ typebox/value        │ '   89 kb' │ '   41 kb' │  '2.15 x'   │\n│ typebox              │ '   12 kb' │ '    6 kb' │  '1.89 x'   │\n└──────────────────────┴────────────┴────────────┴─────────────┘\n```\n\n<a name='contribute'></a>\n\n## Contribute\n\nTypeBox is open to community contribution. Please ensure you submit an open issue before submitting your pull request. The TypeBox project preferences open community discussion prior to accepting new features.\n",
    "licenseText": "TypeBox: JSON Schema Type Builder with Static Type Resolution for TypeScript \n\nThe MIT License (MIT)\n\nCopyright (c) 2017-2023 Haydn Paterson (sinclair) <haydn.developer@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE."
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.yarnpkg.com/@sinclair/typebox/-/typebox-0.25.23.tgz#1c15b0d2b872d89cc0f47c7243eacb447df8b8bd",
    "type": "tarball",
    "reference": "https://registry.yarnpkg.com/@sinclair/typebox/-/typebox-0.25.23.tgz",
    "hash": "1c15b0d2b872d89cc0f47c7243eacb447df8b8bd",
    "integrity": "sha512-VEB8ygeP42CFLWyAJhN5OklpxUliqdNEUcXb4xZ/CINqtYGTjL5ukluKdKzQ0iWdUxyQ7B0539PAUhHKrCNWSQ==",
    "registry": "npm",
    "packageName": "@sinclair/typebox",
    "cacheIntegrity": "sha512-VEB8ygeP42CFLWyAJhN5OklpxUliqdNEUcXb4xZ/CINqtYGTjL5ukluKdKzQ0iWdUxyQ7B0539PAUhHKrCNWSQ== sha1-HBWw0rhy2JzA9HxyQ+rLRH34uL0="
  },
  "registry": "npm",
  "hash": "1c15b0d2b872d89cc0f47c7243eacb447df8b8bd"
}